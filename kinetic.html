<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>3D Particles Of Primisx</title>

<style>
body { margin: 0; overflow: hidden; background: #000; font-family: monospace; }
canvas { display: block; }
#video-feed {
  position: absolute;
  top: 10px;
  left: 10px;
  width: 220px;
  height: 165px;
  opacity: 0.65;
  z-index: 10;
  transform: scaleX(-1);
  filter: brightness(1.4) contrast(1.2);
  border-radius: 8px;
}
#ui {
  position: absolute;
  top: 10px;
  right: 10px;
  color: #0f0;
  text-align: right;
  pointer-events: none;
}
.instruction { font-size: 14px; color: #fff; margin-bottom: 5px; }
.status { color: #0f0; }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

<video id="video-feed" autoplay muted playsinline></video>

<div id="ui">
  <div class="instruction">Status: <span id="status" class="status">Loading PRIMISX...</span></div>
  <div class="instruction">1 Finger → Sphere</div>
  <div class="instruction">2 Fingers → Heart</div>
  <div class="instruction">3 Fingers → Flower</div>
  <div class="instruction">4 Fingers → Saturn</div>
  <div class="instruction">5 Fingers → Move Object</div>
</div>

<script>
// ================= CONFIG =================
const PARTICLE_COUNT = 15000;
const MORPH_SPEED = 0.09;
const PARTICLE_SIZE = 0.15;

// Global State
let currentShape = 'sphere';
let handX = 0, handY = 0;
let moveMode = false;
let stableFingerCount = 0;
let lastFingerCount = 0;
let fingerStableFrames = 0;

// ================= THREE.JS =================
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 32;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

// ================= PARTICLES =================
const shapes = { sphere: [], heart: [], flower: [], saturn: [], fireworks: [] };

const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(PARTICLE_COUNT * 3);
const colors = new Float32Array(PARTICLE_COUNT * 3);

for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
  positions[i] = (Math.random() - 0.5) * 50;
  colors[i] = 1;
}

geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

const material = new THREE.PointsMaterial({
  size: PARTICLE_SIZE,
  vertexColors: true,
  blending: THREE.AdditiveBlending,
  transparent: true,
  opacity: 0.85,
  depthWrite: false
});

const particleSystem = new THREE.Points(geometry, material);
scene.add(particleSystem);

// ================= SHAPES =================
function generateShapes() {
  for (let i = 0; i < PARTICLE_COUNT; i++) {

    // Sphere
    const t = Math.random() * Math.PI * 2;
    const p = Math.acos(2 * Math.random() - 1);
    const r = 10;
    shapes.sphere.push(
      r * Math.sin(p) * Math.cos(t),
      r * Math.sin(p) * Math.sin(t),
      r * Math.cos(p)
    );

    // Heart
    const a = Math.random() * Math.PI * 2;
    const hx = 16 * Math.pow(Math.sin(a), 3);
    const hy = 13 * Math.cos(a) - 5 * Math.cos(2*a) - 2 * Math.cos(3*a) - Math.cos(4*a);
    shapes.heart.push(hx * 0.45, hy * 0.45, (Math.random() - 0.5) * 6);

    // Flower
    const ft = Math.random() * Math.PI * 2;
    const fp = (Math.random() - 0.5) * Math.PI;
    const k = 4;
    const rf = 9 * Math.cos(k * ft) + 3;
    shapes.flower.push(
      rf * Math.cos(ft) * Math.cos(fp),
      rf * Math.sin(ft) * Math.cos(fp),
      9 * Math.sin(fp)
    );

    // Saturn
    if (i < PARTICLE_COUNT * 0.3) {
      const st = Math.random() * Math.PI * 2;
      const sp = Math.acos(2 * Math.random() - 1);
      const sr = 6;
      shapes.saturn.push(
        sr * Math.sin(sp) * Math.cos(st),
        sr * Math.sin(sp) * Math.sin(st),
        sr * Math.cos(sp)
      );
    } else {
      const ra = Math.random() * Math.PI * 2;
      const rr = 9 + Math.random() * 5;
      shapes.saturn.push(rr * Math.cos(ra), (Math.random() - 0.5) * 0.4, rr * Math.sin(ra));
    }

    // Fireworks
    const fwT = Math.random() * Math.PI * 2;
    const fwP = Math.acos(2 * Math.random() - 1);
    const fwR = Math.random() * 20;
    shapes.fireworks.push(
      fwR * Math.sin(fwP) * Math.cos(fwT),
      fwR * Math.sin(fwP) * Math.sin(fwT),
      fwR * Math.cos(fwP)
    );
  }
}
generateShapes();

// ================= ANIMATION =================
function animate() {
  requestAnimationFrame(animate);

  const target = shapes[currentShape];
  const time = performance.now() * 0.001;

  if (moveMode) {
    particleSystem.position.x += (handX * 12 - particleSystem.position.x) * 0.08;
    particleSystem.position.y += (-handY * 12 - particleSystem.position.y) * 0.08;
  } else {
    particleSystem.rotation.y += 0.003 + handX * 0.03;
    particleSystem.rotation.x += handY * 0.03;
  }

  for (let i = 0; i < PARTICLE_COUNT; i++) {
    const ix = i * 3;
    positions[ix] += (target[ix] - positions[ix]) * MORPH_SPEED;
    positions[ix+1] += (target[ix+1] - positions[ix+1]) * MORPH_SPEED;
    positions[ix+2] += (target[ix+2] - positions[ix+2]) * MORPH_SPEED;

    const r = 0.5 + 0.5 * Math.sin(time * 0.6);
    const g = 0.5 + 0.5 * Math.sin(time * 0.6 + 2);
    const b = 0.5 + 0.5 * Math.sin(time * 0.6 + 4);

    colors[ix] += (r - colors[ix]) * 0.05;
    colors[ix+1] += (g - colors[ix+1]) * 0.05;
    colors[ix+2] += (b - colors[ix+2]) * 0.05;
  }

  geometry.attributes.position.needsUpdate = true;
  geometry.attributes.color.needsUpdate = true;

  renderer.render(scene, camera);
}
animate();

// ================= MEDIAPIPE =================
const videoElement = document.getElementById('video-feed');
const statusElement = document.getElementById('status');

function countFingers(landmarks) {
  let count = 0;

  // Thumb
  if (landmarks[4].x < landmarks[3].x) count++;

  // Other fingers
  if (landmarks[8].y < landmarks[6].y) count++;
  if (landmarks[12].y < landmarks[10].y) count++;
  if (landmarks[16].y < landmarks[14].y) count++;
  if (landmarks[20].y < landmarks[18].y) count++;

  return count;
}

function onResults(results) {
  if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
    statusElement.innerText = "No Hand";
    moveMode = false;
    return;
  }

  const lm = results.multiHandLandmarks[0];
  statusElement.innerText = "Tracking";

  const fingers = countFingers(lm);

  // ---- Gesture Stabilization ----
  if (fingers === lastFingerCount) {
    fingerStableFrames++;
  } else {
    fingerStableFrames = 0;
    lastFingerCount = fingers;
  }

  if (fingerStableFrames > 6) {
    stableFingerCount = fingers;
  }

  // ---- Shape Switching ----
  if (stableFingerCount === 1) currentShape = 'sphere';
  else if (stableFingerCount === 2) currentShape = 'heart';
  else if (stableFingerCount === 3) currentShape = 'flower';
  else if (stableFingerCount === 4) currentShape = 'saturn';
  else if (stableFingerCount >= 5) currentShape = 'fireworks';

  // ---- Movement Mode (Open Palm) ----
  moveMode = stableFingerCount === 5;

  // ---- Hand Position ----
  handX = lm[9].x - 0.5;
  handY = lm[9].y - 0.5;
}

const hands = new Hands({
  locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.6,
  minTrackingConfidence: 0.6
});

hands.onResults(onResults);

const cam = new Camera(videoElement, {
  onFrame: async () => {
    await hands.send({ image: videoElement });
  },
  width: 480,
  height: 360
});
cam.start();

// ================= RESIZE =================
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>